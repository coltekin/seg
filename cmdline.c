/*
  File autogenerated by gengetopt version 2.22.6
  generated with the following command:
  gengetopt --set-version= 

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif

#include <getopt.h>

#include "cmdline.h"

const char *gengetopt_args_info_purpose = "purpose";

const char *gengetopt_args_info_usage = "Usage: usage";

const char *gengetopt_args_info_versiontext = "";

const char *gengetopt_args_info_description = "description";

const char *gengetopt_args_info_help[] = {
  "  -h, --help                    Print help and exit",
  "  -V, --version                 Print version and exit",
  "  -d, --debug=INT               debug level  (default=`0')",
  "      --quiet                   be quiet  (default=off)",
  "      --color                   color output  (default=off)",
  "      --progress[=INT]          print progress  (default=`100')",
  "  -i, --input=filename          input file name  (default=`br-phono.txt')",
  "      --stress-file=filename     filename to read stress patterns from",
  "  -f, --input-format=ENUM       input file format:\n                                   seg: one segmented utterance/word per line\n                                   unseg: one unsegmented utterance/word per\n                                  line\n                                   mc: MorphoChallenge format, <freq,unseg>\n                                  pairs  (possible values=\"seg\", \"unseg\",\n                                  \"mc\" default=`seg')",
  "  -o, --output=filename         output file name  (default=`-')",
  "  -I, --inlex=filename          input lexicon file",
  "  -O, --outlex=filename         output lexicon file  (default=`-')",
  "      --shuffle[=SEED]          randomize the input utternaces. if SEED is not\n                                  given, current time is used as seed\n                                  (default=`-1')",
  "\nOptions for printing varios segmentation measures:",
  "  -p, --print                   print predictability measures given in --pred\n                                  and exit  (default=off)",
  "      --print-lb                print word boundary information for each\n                                  measure  (default=off)",
  "      --print-ub                print utterance boundary information for each\n                                  measure  (default=off)",
  "      --print-header            print a header describing each field\n                                  (default=off)",
  "      --print-ph                print the phoneme before the predictability\n                                  measure  (default=off)",
  "      --print-phng              print phoneme ngrams before the predictability\n                                  measure  (default=off)",
  "      --print-ptp[=ENUM]        Print Hockema's ptp values, and some more\n                                  (possible values=\"jp\", \"tp\", \"mi\",\n                                  \"sv\", \"h\", \"rtp\", \"rsv\", \"rh\",\n                                  \"none\" default=`none')",
  "      --print-wfreq[=INT]       Print frequency of all candidate words upto\n                                  length N  (default=`11')",
  "      --print-wfreq-sum         Print summary during --print-wfreq\n                                  (default=off)",
  "      --print-latex             print tabular material with latex separators\n                                  (default=off)",
  "      --print-prf[=INT]         print precision/recall/f-score. If the optional\n                                  argument, N,  is given and positive, print\n                                  the scores after every N input\n                                  utterance. If N is negative, the print the\n                                  scores for last N\n                                  utterances.  (default=`0')",
  "      --score=ENUM              the segmentation to pick in case of multiple\n                                  outputs  (possible values=\"first\",\n                                  \"random\", \"best\", \"any\"\n                                  default=`first')",
  "      --score-edges             include utterance edges in BP/BR calculation\n                                  (default=off)",
  "\nOptions for `lm1' method:",
  "      --alpha=rate              parameter for lm1 segmentation  (default=`0.5')",
  "\nOptions for predictability based segmentation:",
  "      --pred-m=ENUM             measure(s) to use for predictability based\n                                  segmentation  (possible values=\"jp\",\n                                  \"tp\", \"mi\", \"sv\", \"h\", \"rtp\",\n                                  \"rsv\", \"rh\" default=`tp')",
  "      --pred-norm               normalize the predictability scores\n                                  (default=off)",
  "      --pred-xlen=INT           first ngram size for predictability based\n                                  measures  (default=`1')",
  "      --pred-ylen=INT           second ngram size for predictability based\n                                  measures  (default=`1')",
  "      --pred-xmax=INT           max first ngram size for predictability based\n                                  measures  (default=`3')",
  "      --pred-ymax=INT           max second ngram size for predictability based\n                                  measures  (default=`1')",
  "      --pred-xmin=INT           min first ngram size for predictability based\n                                  measures  (default=`1')",
  "      --pred-ymin=INT           min second ngram size for predictability based\n                                  measures  (default=`1')",
  "      --pred-printw             print the final weights at the end of the\n                                  segmentation  (default=off)",
  "      --pred-printoptions       print the options before the segmentation\n                                  (default=off)",
  "      --pred-swaplr             swap the l & r values for reverse measures\n                                  (default=on)",
  "\nOptions for random segmentation:",
  "      --random-seed=INT         seed for pseudo-random number generator",
  "      --random-rate=DOUBLE      rate of boundaries, should be a number between\n                                  0 (no boundaries) an 1 (all boundaries)\n                                  (default=`0.5')",
  "\nOptions for lexicon based segmentation:",
  "      --lexicon-partial[=ENUM]  do partial segmentation  (possible\n                                  values=\"all\", \"one\", \"begin\", \"end\",\n                                  \"beginend\", \"none\" default=`none')",
  "      --lex-nglen=INT           ngram size for keeping statistics about the\n                                  phonemes in the lexicon  (default=`5')",
  "      --lex-useprior            use utterances in --prior-data as initial\n                                  lexicon statistics  (default=on)",
  "      --lex-minfreq=DOUBLE      frequencey of an ngram to qualify as a word\n                                  (default=`0.0')",
  "      --lex-minent=DOUBLE       left and right entropy of an ngram to qualify\n                                  as a word  (default=`-1.0')",
  "      --lex-mult=N              multiply lexicon votes N times  (default=`1')",
  "      --lex-wcombine=ENUM       how to combine LF/LC for multiple words\n                                  (possible values=\"best\", \"mean\", \"sum\"\n                                  default=`sum')",
  "      --lex-norm=ENUM           normalization method for LF/LC  (possible\n                                  values=\"none\", \"z\" default=`none')",
  "      --lex=ENUM                measure(s) to use for lexicon based\n                                  segmentation  (possible values=\"lc\",\n                                  \"lf\", \"lp\" default=`lf')",
  "      --lex-dir=ENUM            direction of lexal measures  (possible\n                                  values=\"lr\", \"rl\", \"both\"\n                                  default=`both')",
  "\nOptions for stress:",
  "      --stress=ENUM             method to calculate stress information\n                                  (possible values=\"ub\", \"transition\",\n                                  \"cheat\", \"sylcheat\" default=`ub')",
  "\nOptions for utterance boundary segmentation:",
  "      --ub-nglen=INT            phoneme ngram length  (default=`2')",
  "      --ub-ngmin=INT            minimum phoneme ngram length  (default=`1')",
  "      --ub-ngmax=INT            maximum phoneme ngram length  (default=`3')",
  "      --ub-lmin=INT             maximum left phoneme ngram length\n                                  (default=`1')",
  "      --ub-lmax=INT             minimum left phoneme ngram length\n                                  (default=`3')",
  "      --ub-rmin=INT             maximum right phoneme ngram length\n                                  (default=`1')",
  "      --ub-rmax=INT             minimum right phoneme ngram length\n                                  (default=`3')",
  "      --ub-type=ENUM            part of the utterance boundaries to use\n                                  (possible values=\"ubegin\", \"uend\",\n                                  \"both\" default=`both')",
  "      --sub-ngmin=INT           minimum ngram length for stress (otherwise\n                                  inherited from ub-ngmin)  (default=`2')",
  "      --sub-ngmax=INT           maximum ngram length for stress (otherwise\n                                  inherited from ub-ngmax)  (default=`2')",
  "\nGeneral options for segmentation:",
  "  -m, --method=ENUM             segmentation method(s), some can be combined\n                                  (possible values=\"lexicon\", \"lm\",\n                                  \"random\", \"pred\", \"ub\", \"lexc\",\n                                  \"nv\", \"combine\" default=`combine')",
  "  -c, --cues=ENUM               list of cues to combine  (possible\n                                  values=\"pred\", \"phon\", \"stress\",\n                                  \"lex\" default=`pred')",
  "      --cue-source=ENUM         default source for all cues  (possible\n                                  values=\"utterances\", \"segments\",\n                                  \"lexicon\" default=`utterances')",
  "      --psb-cheat               update statistics for source=segm first from\n                                  the utterances, and later when boundaries are\n                                  decided  (default=off)",
  "      --pred-source=ENUM        source for all predictability statistics\n                                  (possible values=\"utterances\",\n                                  \"segments\", \"lexicon\")",
  "      --phon-source=ENUM        source for all phonotactics statistics\n                                  (possible values=\"utterances\",\n                                  \"segments\", \"lexicon\")",
  "      --stress-source=ENUM      source for all stress statistics  (possible\n                                  values=\"utterances\", \"segments\",\n                                  \"lexicon\")",
  "      --lex-source=ENUM         source for all lexicon statistics  (possible\n                                  values=\"utterances\", \"segments\",\n                                  \"lexicon\")",
  "      --combine=ENUM            combination method for multiple cues  (possible\n                                  values=\"mv\", \"wmv\", \"all\", \"any\"\n                                  default=`wmv')",
  "      --combine-rate=rate       rate of votes for deciding for a boundary\n                                  (default=`0.5')",
  "      --boundary-method=ENUM    method to decide for a boundary  (possible\n                                  values=\"peak\", \"threshold\", \"none\",\n                                  \"all\" default=`peak')",
  "      --peak=ENUM               how to count peaks for peak based decision\n                                  (possible values=\"strict\", \"relaxed\",\n                                  \"dual\", \"right\", \"left\", \"lr\",\n                                  \"strict2\" default=`dual')",
  "      --threshold=th            threshold to use for deciding boundaries\n                                  (default=`0.0')",
  "      --norm=method             normalize the measures with given method before\n                                  using  (possible values=\"none\", \"zscore\",\n                                  \"mdiff\", \"mdivide\" default=`none')",
  "      --vote=ENUM               what to return as vote  (possible\n                                  values=\"binary\", \"diff\", \"lgdiff\"\n                                  default=`binary')",
  "      --prior-data[=filename]   filename to build prior statistics from, if\n                                  filename is not specified, the statistics are\n                                  calculated on the first pass on the input\n                                  file.  (default=`input')",
  "For filename arguments `-' means stdin or stdout",
    0
};

typedef enum {ARG_NO
  , ARG_FLAG
  , ARG_STRING
  , ARG_INT
  , ARG_LONG
  , ARG_DOUBLE
  , ARG_ENUM
} cmdline_parser_arg_type;

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error);

static int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);

const char *cmdline_parser_input_format_values[] = {"seg", "unseg", "mc", 0}; /*< Possible values for input-format. */
const char *cmdline_parser_print_ptp_values[] = {"jp", "tp", "mi", "sv", "h", "rtp", "rsv", "rh", "none", 0}; /*< Possible values for print-ptp. */
const char *cmdline_parser_score_values[] = {"first", "random", "best", "any", 0}; /*< Possible values for score. */
const char *cmdline_parser_pred_m_values[] = {"jp", "tp", "mi", "sv", "h", "rtp", "rsv", "rh", 0}; /*< Possible values for pred-m. */
const char *cmdline_parser_lexicon_partial_values[] = {"all", "one", "begin", "end", "beginend", "none", 0}; /*< Possible values for lexicon-partial. */
const char *cmdline_parser_lex_wcombine_values[] = {"best", "mean", "sum", 0}; /*< Possible values for lex-wcombine. */
const char *cmdline_parser_lex_norm_values[] = {"none", "z", 0}; /*< Possible values for lex-norm. */
const char *cmdline_parser_lex_values[] = {"lc", "lf", "lp", 0}; /*< Possible values for lex. */
const char *cmdline_parser_lex_dir_values[] = {"lr", "rl", "both", 0}; /*< Possible values for lex-dir. */
const char *cmdline_parser_stress_values[] = {"ub", "transition", "cheat", "sylcheat", 0}; /*< Possible values for stress. */
const char *cmdline_parser_ub_type_values[] = {"ubegin", "uend", "both", 0}; /*< Possible values for ub-type. */
const char *cmdline_parser_method_values[] = {"lexicon", "lm", "random", "pred", "ub", "lexc", "nv", "combine", 0}; /*< Possible values for method. */
const char *cmdline_parser_cues_values[] = {"pred", "phon", "stress", "lex", 0}; /*< Possible values for cues. */
const char *cmdline_parser_cue_source_values[] = {"utterances", "segments", "lexicon", 0}; /*< Possible values for cue-source. */
const char *cmdline_parser_pred_source_values[] = {"utterances", "segments", "lexicon", 0}; /*< Possible values for pred-source. */
const char *cmdline_parser_phon_source_values[] = {"utterances", "segments", "lexicon", 0}; /*< Possible values for phon-source. */
const char *cmdline_parser_stress_source_values[] = {"utterances", "segments", "lexicon", 0}; /*< Possible values for stress-source. */
const char *cmdline_parser_lex_source_values[] = {"utterances", "segments", "lexicon", 0}; /*< Possible values for lex-source. */
const char *cmdline_parser_combine_values[] = {"mv", "wmv", "all", "any", 0}; /*< Possible values for combine. */
const char *cmdline_parser_boundary_method_values[] = {"peak", "threshold", "none", "all", 0}; /*< Possible values for boundary-method. */
const char *cmdline_parser_peak_values[] = {"strict", "relaxed", "dual", "right", "left", "lr", "strict2", 0}; /*< Possible values for peak. */
const char *cmdline_parser_norm_values[] = {"none", "zscore", "mdiff", "mdivide", 0}; /*< Possible values for norm. */
const char *cmdline_parser_vote_values[] = {"binary", "diff", "lgdiff", 0}; /*< Possible values for vote. */

static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->debug_given = 0 ;
  args_info->quiet_given = 0 ;
  args_info->color_given = 0 ;
  args_info->progress_given = 0 ;
  args_info->input_given = 0 ;
  args_info->stress_file_given = 0 ;
  args_info->input_format_given = 0 ;
  args_info->output_given = 0 ;
  args_info->inlex_given = 0 ;
  args_info->outlex_given = 0 ;
  args_info->shuffle_given = 0 ;
  args_info->print_given = 0 ;
  args_info->print_lb_given = 0 ;
  args_info->print_ub_given = 0 ;
  args_info->print_header_given = 0 ;
  args_info->print_ph_given = 0 ;
  args_info->print_phng_given = 0 ;
  args_info->print_ptp_given = 0 ;
  args_info->print_wfreq_given = 0 ;
  args_info->print_wfreq_sum_given = 0 ;
  args_info->print_latex_given = 0 ;
  args_info->print_prf_given = 0 ;
  args_info->score_given = 0 ;
  args_info->score_edges_given = 0 ;
  args_info->alpha_given = 0 ;
  args_info->pred_m_given = 0 ;
  args_info->pred_norm_given = 0 ;
  args_info->pred_xlen_given = 0 ;
  args_info->pred_ylen_given = 0 ;
  args_info->pred_xmax_given = 0 ;
  args_info->pred_ymax_given = 0 ;
  args_info->pred_xmin_given = 0 ;
  args_info->pred_ymin_given = 0 ;
  args_info->pred_printw_given = 0 ;
  args_info->pred_printoptions_given = 0 ;
  args_info->pred_swaplr_given = 0 ;
  args_info->random_seed_given = 0 ;
  args_info->random_rate_given = 0 ;
  args_info->lexicon_partial_given = 0 ;
  args_info->lex_nglen_given = 0 ;
  args_info->lex_useprior_given = 0 ;
  args_info->lex_minfreq_given = 0 ;
  args_info->lex_minent_given = 0 ;
  args_info->lex_mult_given = 0 ;
  args_info->lex_wcombine_given = 0 ;
  args_info->lex_norm_given = 0 ;
  args_info->lex_given = 0 ;
  args_info->lex_dir_given = 0 ;
  args_info->stress_given = 0 ;
  args_info->ub_nglen_given = 0 ;
  args_info->ub_ngmin_given = 0 ;
  args_info->ub_ngmax_given = 0 ;
  args_info->ub_lmin_given = 0 ;
  args_info->ub_lmax_given = 0 ;
  args_info->ub_rmin_given = 0 ;
  args_info->ub_rmax_given = 0 ;
  args_info->ub_type_given = 0 ;
  args_info->sub_ngmin_given = 0 ;
  args_info->sub_ngmax_given = 0 ;
  args_info->method_given = 0 ;
  args_info->cues_given = 0 ;
  args_info->cue_source_given = 0 ;
  args_info->psb_cheat_given = 0 ;
  args_info->pred_source_given = 0 ;
  args_info->phon_source_given = 0 ;
  args_info->stress_source_given = 0 ;
  args_info->lex_source_given = 0 ;
  args_info->combine_given = 0 ;
  args_info->combine_rate_given = 0 ;
  args_info->boundary_method_given = 0 ;
  args_info->peak_given = 0 ;
  args_info->threshold_given = 0 ;
  args_info->norm_given = 0 ;
  args_info->vote_given = 0 ;
  args_info->prior_data_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  FIX_UNUSED (args_info);
  args_info->debug_arg = 0;
  args_info->debug_orig = NULL;
  args_info->quiet_flag = 0;
  args_info->color_flag = 0;
  args_info->progress_arg = 100;
  args_info->progress_orig = NULL;
  args_info->input_arg = gengetopt_strdup ("br-phono.txt");
  args_info->input_orig = NULL;
  args_info->stress_file_arg = NULL;
  args_info->stress_file_orig = NULL;
  args_info->input_format_arg = input_format_arg_seg;
  args_info->input_format_orig = NULL;
  args_info->output_arg = gengetopt_strdup ("-");
  args_info->output_orig = NULL;
  args_info->inlex_arg = NULL;
  args_info->inlex_orig = NULL;
  args_info->outlex_arg = gengetopt_strdup ("-");
  args_info->outlex_orig = NULL;
  args_info->shuffle_arg = -1;
  args_info->shuffle_orig = NULL;
  args_info->print_flag = 0;
  args_info->print_lb_flag = 0;
  args_info->print_ub_flag = 0;
  args_info->print_header_flag = 0;
  args_info->print_ph_flag = 0;
  args_info->print_phng_flag = 0;
  args_info->print_ptp_arg = NULL;
  args_info->print_ptp_orig = NULL;
  args_info->print_wfreq_arg = 11;
  args_info->print_wfreq_orig = NULL;
  args_info->print_wfreq_sum_flag = 0;
  args_info->print_latex_flag = 0;
  args_info->print_prf_arg = 0;
  args_info->print_prf_orig = NULL;
  args_info->score_arg = score_arg_first;
  args_info->score_orig = NULL;
  args_info->score_edges_flag = 0;
  args_info->alpha_arg = 0.5;
  args_info->alpha_orig = NULL;
  args_info->pred_m_arg = NULL;
  args_info->pred_m_orig = NULL;
  args_info->pred_norm_flag = 0;
  args_info->pred_xlen_arg = 1;
  args_info->pred_xlen_orig = NULL;
  args_info->pred_ylen_arg = 1;
  args_info->pred_ylen_orig = NULL;
  args_info->pred_xmax_arg = 3;
  args_info->pred_xmax_orig = NULL;
  args_info->pred_ymax_arg = 1;
  args_info->pred_ymax_orig = NULL;
  args_info->pred_xmin_arg = 1;
  args_info->pred_xmin_orig = NULL;
  args_info->pred_ymin_arg = 1;
  args_info->pred_ymin_orig = NULL;
  args_info->pred_printw_flag = 0;
  args_info->pred_printoptions_flag = 0;
  args_info->pred_swaplr_flag = 1;
  args_info->random_seed_orig = NULL;
  args_info->random_rate_arg = 0.5;
  args_info->random_rate_orig = NULL;
  args_info->lexicon_partial_arg = lexicon_partial_arg_none;
  args_info->lexicon_partial_orig = NULL;
  args_info->lex_nglen_arg = 5;
  args_info->lex_nglen_orig = NULL;
  args_info->lex_useprior_flag = 1;
  args_info->lex_minfreq_arg = 0.0;
  args_info->lex_minfreq_orig = NULL;
  args_info->lex_minent_arg = -1.0;
  args_info->lex_minent_orig = NULL;
  args_info->lex_mult_arg = 1;
  args_info->lex_mult_orig = NULL;
  args_info->lex_wcombine_arg = lex_wcombine_arg_sum;
  args_info->lex_wcombine_orig = NULL;
  args_info->lex_norm_arg = lex_norm_arg_none;
  args_info->lex_norm_orig = NULL;
  args_info->lex_arg = NULL;
  args_info->lex_orig = NULL;
  args_info->lex_dir_arg = lex_dir_arg_both;
  args_info->lex_dir_orig = NULL;
  args_info->stress_arg = stress_arg_ub;
  args_info->stress_orig = NULL;
  args_info->ub_nglen_arg = 2;
  args_info->ub_nglen_orig = NULL;
  args_info->ub_ngmin_arg = 1;
  args_info->ub_ngmin_orig = NULL;
  args_info->ub_ngmax_arg = 3;
  args_info->ub_ngmax_orig = NULL;
  args_info->ub_lmin_arg = 1;
  args_info->ub_lmin_orig = NULL;
  args_info->ub_lmax_arg = 3;
  args_info->ub_lmax_orig = NULL;
  args_info->ub_rmin_arg = 1;
  args_info->ub_rmin_orig = NULL;
  args_info->ub_rmax_arg = 3;
  args_info->ub_rmax_orig = NULL;
  args_info->ub_type_arg = ub_type_arg_both;
  args_info->ub_type_orig = NULL;
  args_info->sub_ngmin_arg = 2;
  args_info->sub_ngmin_orig = NULL;
  args_info->sub_ngmax_arg = 2;
  args_info->sub_ngmax_orig = NULL;
  args_info->method_arg = method_arg_combine;
  args_info->method_orig = NULL;
  args_info->cues_arg = NULL;
  args_info->cues_orig = NULL;
  args_info->cue_source_arg = cue_source_arg_utterances;
  args_info->cue_source_orig = NULL;
  args_info->psb_cheat_flag = 0;
  args_info->pred_source_arg = pred_source__NULL;
  args_info->pred_source_orig = NULL;
  args_info->phon_source_arg = phon_source__NULL;
  args_info->phon_source_orig = NULL;
  args_info->stress_source_arg = stress_source__NULL;
  args_info->stress_source_orig = NULL;
  args_info->lex_source_arg = lex_source__NULL;
  args_info->lex_source_orig = NULL;
  args_info->combine_arg = combine_arg_wmv;
  args_info->combine_orig = NULL;
  args_info->combine_rate_arg = 0.5;
  args_info->combine_rate_orig = NULL;
  args_info->boundary_method_arg = boundary_method_arg_peak;
  args_info->boundary_method_orig = NULL;
  args_info->peak_arg = peak_arg_dual;
  args_info->peak_orig = NULL;
  args_info->threshold_arg = 0.0;
  args_info->threshold_orig = NULL;
  args_info->norm_arg = norm_arg_none;
  args_info->norm_orig = NULL;
  args_info->vote_arg = vote_arg_binary;
  args_info->vote_orig = NULL;
  args_info->prior_data_arg = gengetopt_strdup ("input");
  args_info->prior_data_orig = NULL;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{


  args_info->help_help = gengetopt_args_info_help[0] ;
  args_info->version_help = gengetopt_args_info_help[1] ;
  args_info->debug_help = gengetopt_args_info_help[2] ;
  args_info->quiet_help = gengetopt_args_info_help[3] ;
  args_info->color_help = gengetopt_args_info_help[4] ;
  args_info->progress_help = gengetopt_args_info_help[5] ;
  args_info->input_help = gengetopt_args_info_help[6] ;
  args_info->stress_file_help = gengetopt_args_info_help[7] ;
  args_info->input_format_help = gengetopt_args_info_help[8] ;
  args_info->output_help = gengetopt_args_info_help[9] ;
  args_info->inlex_help = gengetopt_args_info_help[10] ;
  args_info->outlex_help = gengetopt_args_info_help[11] ;
  args_info->shuffle_help = gengetopt_args_info_help[12] ;
  args_info->print_help = gengetopt_args_info_help[14] ;
  args_info->print_lb_help = gengetopt_args_info_help[15] ;
  args_info->print_ub_help = gengetopt_args_info_help[16] ;
  args_info->print_header_help = gengetopt_args_info_help[17] ;
  args_info->print_ph_help = gengetopt_args_info_help[18] ;
  args_info->print_phng_help = gengetopt_args_info_help[19] ;
  args_info->print_ptp_help = gengetopt_args_info_help[20] ;
  args_info->print_ptp_min = 0;
  args_info->print_ptp_max = 0;
  args_info->print_wfreq_help = gengetopt_args_info_help[21] ;
  args_info->print_wfreq_sum_help = gengetopt_args_info_help[22] ;
  args_info->print_latex_help = gengetopt_args_info_help[23] ;
  args_info->print_prf_help = gengetopt_args_info_help[24] ;
  args_info->score_help = gengetopt_args_info_help[25] ;
  args_info->score_edges_help = gengetopt_args_info_help[26] ;
  args_info->alpha_help = gengetopt_args_info_help[28] ;
  args_info->pred_m_help = gengetopt_args_info_help[30] ;
  args_info->pred_m_min = 0;
  args_info->pred_m_max = 0;
  args_info->pred_norm_help = gengetopt_args_info_help[31] ;
  args_info->pred_xlen_help = gengetopt_args_info_help[32] ;
  args_info->pred_ylen_help = gengetopt_args_info_help[33] ;
  args_info->pred_xmax_help = gengetopt_args_info_help[34] ;
  args_info->pred_ymax_help = gengetopt_args_info_help[35] ;
  args_info->pred_xmin_help = gengetopt_args_info_help[36] ;
  args_info->pred_ymin_help = gengetopt_args_info_help[37] ;
  args_info->pred_printw_help = gengetopt_args_info_help[38] ;
  args_info->pred_printoptions_help = gengetopt_args_info_help[39] ;
  args_info->pred_swaplr_help = gengetopt_args_info_help[40] ;
  args_info->random_seed_help = gengetopt_args_info_help[42] ;
  args_info->random_rate_help = gengetopt_args_info_help[43] ;
  args_info->lexicon_partial_help = gengetopt_args_info_help[45] ;
  args_info->lex_nglen_help = gengetopt_args_info_help[46] ;
  args_info->lex_useprior_help = gengetopt_args_info_help[47] ;
  args_info->lex_minfreq_help = gengetopt_args_info_help[48] ;
  args_info->lex_minent_help = gengetopt_args_info_help[49] ;
  args_info->lex_mult_help = gengetopt_args_info_help[50] ;
  args_info->lex_wcombine_help = gengetopt_args_info_help[51] ;
  args_info->lex_norm_help = gengetopt_args_info_help[52] ;
  args_info->lex_help = gengetopt_args_info_help[53] ;
  args_info->lex_min = 0;
  args_info->lex_max = 0;
  args_info->lex_dir_help = gengetopt_args_info_help[54] ;
  args_info->stress_help = gengetopt_args_info_help[56] ;
  args_info->ub_nglen_help = gengetopt_args_info_help[58] ;
  args_info->ub_ngmin_help = gengetopt_args_info_help[59] ;
  args_info->ub_ngmax_help = gengetopt_args_info_help[60] ;
  args_info->ub_lmin_help = gengetopt_args_info_help[61] ;
  args_info->ub_lmax_help = gengetopt_args_info_help[62] ;
  args_info->ub_rmin_help = gengetopt_args_info_help[63] ;
  args_info->ub_rmax_help = gengetopt_args_info_help[64] ;
  args_info->ub_type_help = gengetopt_args_info_help[65] ;
  args_info->sub_ngmin_help = gengetopt_args_info_help[66] ;
  args_info->sub_ngmax_help = gengetopt_args_info_help[67] ;
  args_info->method_help = gengetopt_args_info_help[69] ;
  args_info->cues_help = gengetopt_args_info_help[70] ;
  args_info->cues_min = 0;
  args_info->cues_max = 0;
  args_info->cue_source_help = gengetopt_args_info_help[71] ;
  args_info->psb_cheat_help = gengetopt_args_info_help[72] ;
  args_info->pred_source_help = gengetopt_args_info_help[73] ;
  args_info->phon_source_help = gengetopt_args_info_help[74] ;
  args_info->stress_source_help = gengetopt_args_info_help[75] ;
  args_info->lex_source_help = gengetopt_args_info_help[76] ;
  args_info->combine_help = gengetopt_args_info_help[77] ;
  args_info->combine_rate_help = gengetopt_args_info_help[78] ;
  args_info->boundary_method_help = gengetopt_args_info_help[79] ;
  args_info->peak_help = gengetopt_args_info_help[80] ;
  args_info->threshold_help = gengetopt_args_info_help[81] ;
  args_info->norm_help = gengetopt_args_info_help[82] ;
  args_info->vote_help = gengetopt_args_info_help[83] ;
  args_info->prior_data_help = gengetopt_args_info_help[84] ;
  
}

void
cmdline_parser_print_version (void)
{
  printf ("%s %s\n",
     (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),
     CMDLINE_PARSER_VERSION);

  if (strlen(gengetopt_args_info_versiontext) > 0)
    printf("\n%s\n", gengetopt_args_info_versiontext);
}

static void print_help_common(void) {
  cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  if (strlen(gengetopt_args_info_usage) > 0)
    printf("\n%s\n", gengetopt_args_info_usage);

  printf("\n");

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n\n", gengetopt_args_info_description);
}

void
cmdline_parser_print_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);
}

void
cmdline_parser_params_init(struct cmdline_parser_params *params)
{
  if (params)
    { 
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}

struct cmdline_parser_params *
cmdline_parser_params_create(void)
{
  struct cmdline_parser_params *params = 
    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));
  cmdline_parser_params_init(params);  
  return params;
}

static void
free_string_field (char **s)
{
  if (*s)
    {
      free (*s);
      *s = 0;
    }
}

/** @brief generic value variable */
union generic_value {
    int int_arg;
    long long_arg;
    double double_arg;
    char *string_arg;
    const char *default_string_arg;
};

/** @brief holds temporary values for multiple options */
struct generic_list
{
  union generic_value arg;
  char *orig;
  struct generic_list *next;
};

/**
 * @brief add a node at the head of the list 
 */
static void add_node(struct generic_list **list) {
  struct generic_list *new_node = (struct generic_list *) malloc (sizeof (struct generic_list));
  new_node->next = *list;
  *list = new_node;
  new_node->arg.string_arg = 0;
  new_node->orig = 0;
}

/**
 * The passed arg parameter is NOT set to 0 from this function
 */
static void
free_multiple_field(unsigned int len, void *arg, char ***orig)
{
  unsigned int i;
  if (arg) {
    for (i = 0; i < len; ++i)
      {
        free_string_field(&((*orig)[i]));
      }

    free (arg);
    free (*orig);
    *orig = 0;
  }
}


static void
cmdline_parser_release (struct gengetopt_args_info *args_info)
{

  free_string_field (&(args_info->debug_orig));
  free_string_field (&(args_info->progress_orig));
  free_string_field (&(args_info->input_arg));
  free_string_field (&(args_info->input_orig));
  free_string_field (&(args_info->stress_file_arg));
  free_string_field (&(args_info->stress_file_orig));
  free_string_field (&(args_info->input_format_orig));
  free_string_field (&(args_info->output_arg));
  free_string_field (&(args_info->output_orig));
  free_string_field (&(args_info->inlex_arg));
  free_string_field (&(args_info->inlex_orig));
  free_string_field (&(args_info->outlex_arg));
  free_string_field (&(args_info->outlex_orig));
  free_string_field (&(args_info->shuffle_orig));
  free_multiple_field (args_info->print_ptp_given, (void *)(args_info->print_ptp_arg), &(args_info->print_ptp_orig));
  args_info->print_ptp_arg = 0;
  free_string_field (&(args_info->print_wfreq_orig));
  free_string_field (&(args_info->print_prf_orig));
  free_string_field (&(args_info->score_orig));
  free_string_field (&(args_info->alpha_orig));
  free_multiple_field (args_info->pred_m_given, (void *)(args_info->pred_m_arg), &(args_info->pred_m_orig));
  args_info->pred_m_arg = 0;
  free_string_field (&(args_info->pred_xlen_orig));
  free_string_field (&(args_info->pred_ylen_orig));
  free_string_field (&(args_info->pred_xmax_orig));
  free_string_field (&(args_info->pred_ymax_orig));
  free_string_field (&(args_info->pred_xmin_orig));
  free_string_field (&(args_info->pred_ymin_orig));
  free_string_field (&(args_info->random_seed_orig));
  free_string_field (&(args_info->random_rate_orig));
  free_string_field (&(args_info->lexicon_partial_orig));
  free_string_field (&(args_info->lex_nglen_orig));
  free_string_field (&(args_info->lex_minfreq_orig));
  free_string_field (&(args_info->lex_minent_orig));
  free_string_field (&(args_info->lex_mult_orig));
  free_string_field (&(args_info->lex_wcombine_orig));
  free_string_field (&(args_info->lex_norm_orig));
  free_multiple_field (args_info->lex_given, (void *)(args_info->lex_arg), &(args_info->lex_orig));
  args_info->lex_arg = 0;
  free_string_field (&(args_info->lex_dir_orig));
  free_string_field (&(args_info->stress_orig));
  free_string_field (&(args_info->ub_nglen_orig));
  free_string_field (&(args_info->ub_ngmin_orig));
  free_string_field (&(args_info->ub_ngmax_orig));
  free_string_field (&(args_info->ub_lmin_orig));
  free_string_field (&(args_info->ub_lmax_orig));
  free_string_field (&(args_info->ub_rmin_orig));
  free_string_field (&(args_info->ub_rmax_orig));
  free_string_field (&(args_info->ub_type_orig));
  free_string_field (&(args_info->sub_ngmin_orig));
  free_string_field (&(args_info->sub_ngmax_orig));
  free_string_field (&(args_info->method_orig));
  free_multiple_field (args_info->cues_given, (void *)(args_info->cues_arg), &(args_info->cues_orig));
  args_info->cues_arg = 0;
  free_string_field (&(args_info->cue_source_orig));
  free_string_field (&(args_info->pred_source_orig));
  free_string_field (&(args_info->phon_source_orig));
  free_string_field (&(args_info->stress_source_orig));
  free_string_field (&(args_info->lex_source_orig));
  free_string_field (&(args_info->combine_orig));
  free_string_field (&(args_info->combine_rate_orig));
  free_string_field (&(args_info->boundary_method_orig));
  free_string_field (&(args_info->peak_orig));
  free_string_field (&(args_info->threshold_orig));
  free_string_field (&(args_info->norm_orig));
  free_string_field (&(args_info->vote_orig));
  free_string_field (&(args_info->prior_data_arg));
  free_string_field (&(args_info->prior_data_orig));
  
  

  clear_given (args_info);
}

/**
 * @param val the value to check
 * @param values the possible values
 * @return the index of the matched value:
 * -1 if no value matched,
 * -2 if more than one value has matched
 */
static int
check_possible_values(const char *val, const char *values[])
{
  int i, found, last;
  size_t len;

  if (!val)   /* otherwise strlen() crashes below */
    return -1; /* -1 means no argument for the option */

  found = last = 0;

  for (i = 0, len = strlen(val); values[i]; ++i)
    {
      if (strncmp(val, values[i], len) == 0)
        {
          ++found;
          last = i;
          if (strlen(values[i]) == len)
            return i; /* exact macth no need to check more */
        }
    }

  if (found == 1) /* one match: OK */
    return last;

  return (found ? -2 : -1); /* return many values or none matched */
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
{
  int found = -1;
  if (arg) {
    if (values) {
      found = check_possible_values(arg, values);      
    }
    if (found >= 0)
      fprintf(outfile, "%s=\"%s\" # %s\n", opt, arg, values[found]);
    else
      fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}

static void
write_multiple_into_file(FILE *outfile, int len, const char *opt, char **arg, const char *values[])
{
  int i;
  
  for (i = 0; i < len; ++i)
    write_into_file(outfile, opt, (arg ? arg[i] : 0), values);
}

int
cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
{
  int i = 0;

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot dump options to stream\n", CMDLINE_PARSER_PACKAGE);
      return EXIT_FAILURE;
    }

  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0 );
  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0 );
  if (args_info->debug_given)
    write_into_file(outfile, "debug", args_info->debug_orig, 0);
  if (args_info->quiet_given)
    write_into_file(outfile, "quiet", 0, 0 );
  if (args_info->color_given)
    write_into_file(outfile, "color", 0, 0 );
  if (args_info->progress_given)
    write_into_file(outfile, "progress", args_info->progress_orig, 0);
  if (args_info->input_given)
    write_into_file(outfile, "input", args_info->input_orig, 0);
  if (args_info->stress_file_given)
    write_into_file(outfile, "stress-file", args_info->stress_file_orig, 0);
  if (args_info->input_format_given)
    write_into_file(outfile, "input-format", args_info->input_format_orig, cmdline_parser_input_format_values);
  if (args_info->output_given)
    write_into_file(outfile, "output", args_info->output_orig, 0);
  if (args_info->inlex_given)
    write_into_file(outfile, "inlex", args_info->inlex_orig, 0);
  if (args_info->outlex_given)
    write_into_file(outfile, "outlex", args_info->outlex_orig, 0);
  if (args_info->shuffle_given)
    write_into_file(outfile, "shuffle", args_info->shuffle_orig, 0);
  if (args_info->print_given)
    write_into_file(outfile, "print", 0, 0 );
  if (args_info->print_lb_given)
    write_into_file(outfile, "print-lb", 0, 0 );
  if (args_info->print_ub_given)
    write_into_file(outfile, "print-ub", 0, 0 );
  if (args_info->print_header_given)
    write_into_file(outfile, "print-header", 0, 0 );
  if (args_info->print_ph_given)
    write_into_file(outfile, "print-ph", 0, 0 );
  if (args_info->print_phng_given)
    write_into_file(outfile, "print-phng", 0, 0 );
  write_multiple_into_file(outfile, args_info->print_ptp_given, "print-ptp", args_info->print_ptp_orig, cmdline_parser_print_ptp_values);
  if (args_info->print_wfreq_given)
    write_into_file(outfile, "print-wfreq", args_info->print_wfreq_orig, 0);
  if (args_info->print_wfreq_sum_given)
    write_into_file(outfile, "print-wfreq-sum", 0, 0 );
  if (args_info->print_latex_given)
    write_into_file(outfile, "print-latex", 0, 0 );
  if (args_info->print_prf_given)
    write_into_file(outfile, "print-prf", args_info->print_prf_orig, 0);
  if (args_info->score_given)
    write_into_file(outfile, "score", args_info->score_orig, cmdline_parser_score_values);
  if (args_info->score_edges_given)
    write_into_file(outfile, "score-edges", 0, 0 );
  if (args_info->alpha_given)
    write_into_file(outfile, "alpha", args_info->alpha_orig, 0);
  write_multiple_into_file(outfile, args_info->pred_m_given, "pred-m", args_info->pred_m_orig, cmdline_parser_pred_m_values);
  if (args_info->pred_norm_given)
    write_into_file(outfile, "pred-norm", 0, 0 );
  if (args_info->pred_xlen_given)
    write_into_file(outfile, "pred-xlen", args_info->pred_xlen_orig, 0);
  if (args_info->pred_ylen_given)
    write_into_file(outfile, "pred-ylen", args_info->pred_ylen_orig, 0);
  if (args_info->pred_xmax_given)
    write_into_file(outfile, "pred-xmax", args_info->pred_xmax_orig, 0);
  if (args_info->pred_ymax_given)
    write_into_file(outfile, "pred-ymax", args_info->pred_ymax_orig, 0);
  if (args_info->pred_xmin_given)
    write_into_file(outfile, "pred-xmin", args_info->pred_xmin_orig, 0);
  if (args_info->pred_ymin_given)
    write_into_file(outfile, "pred-ymin", args_info->pred_ymin_orig, 0);
  if (args_info->pred_printw_given)
    write_into_file(outfile, "pred-printw", 0, 0 );
  if (args_info->pred_printoptions_given)
    write_into_file(outfile, "pred-printoptions", 0, 0 );
  if (args_info->pred_swaplr_given)
    write_into_file(outfile, "pred-swaplr", 0, 0 );
  if (args_info->random_seed_given)
    write_into_file(outfile, "random-seed", args_info->random_seed_orig, 0);
  if (args_info->random_rate_given)
    write_into_file(outfile, "random-rate", args_info->random_rate_orig, 0);
  if (args_info->lexicon_partial_given)
    write_into_file(outfile, "lexicon-partial", args_info->lexicon_partial_orig, cmdline_parser_lexicon_partial_values);
  if (args_info->lex_nglen_given)
    write_into_file(outfile, "lex-nglen", args_info->lex_nglen_orig, 0);
  if (args_info->lex_useprior_given)
    write_into_file(outfile, "lex-useprior", 0, 0 );
  if (args_info->lex_minfreq_given)
    write_into_file(outfile, "lex-minfreq", args_info->lex_minfreq_orig, 0);
  if (args_info->lex_minent_given)
    write_into_file(outfile, "lex-minent", args_info->lex_minent_orig, 0);
  if (args_info->lex_mult_given)
    write_into_file(outfile, "lex-mult", args_info->lex_mult_orig, 0);
  if (args_info->lex_wcombine_given)
    write_into_file(outfile, "lex-wcombine", args_info->lex_wcombine_orig, cmdline_parser_lex_wcombine_values);
  if (args_info->lex_norm_given)
    write_into_file(outfile, "lex-norm", args_info->lex_norm_orig, cmdline_parser_lex_norm_values);
  write_multiple_into_file(outfile, args_info->lex_given, "lex", args_info->lex_orig, cmdline_parser_lex_values);
  if (args_info->lex_dir_given)
    write_into_file(outfile, "lex-dir", args_info->lex_dir_orig, cmdline_parser_lex_dir_values);
  if (args_info->stress_given)
    write_into_file(outfile, "stress", args_info->stress_orig, cmdline_parser_stress_values);
  if (args_info->ub_nglen_given)
    write_into_file(outfile, "ub-nglen", args_info->ub_nglen_orig, 0);
  if (args_info->ub_ngmin_given)
    write_into_file(outfile, "ub-ngmin", args_info->ub_ngmin_orig, 0);
  if (args_info->ub_ngmax_given)
    write_into_file(outfile, "ub-ngmax", args_info->ub_ngmax_orig, 0);
  if (args_info->ub_lmin_given)
    write_into_file(outfile, "ub-lmin", args_info->ub_lmin_orig, 0);
  if (args_info->ub_lmax_given)
    write_into_file(outfile, "ub-lmax", args_info->ub_lmax_orig, 0);
  if (args_info->ub_rmin_given)
    write_into_file(outfile, "ub-rmin", args_info->ub_rmin_orig, 0);
  if (args_info->ub_rmax_given)
    write_into_file(outfile, "ub-rmax", args_info->ub_rmax_orig, 0);
  if (args_info->ub_type_given)
    write_into_file(outfile, "ub-type", args_info->ub_type_orig, cmdline_parser_ub_type_values);
  if (args_info->sub_ngmin_given)
    write_into_file(outfile, "sub-ngmin", args_info->sub_ngmin_orig, 0);
  if (args_info->sub_ngmax_given)
    write_into_file(outfile, "sub-ngmax", args_info->sub_ngmax_orig, 0);
  if (args_info->method_given)
    write_into_file(outfile, "method", args_info->method_orig, cmdline_parser_method_values);
  write_multiple_into_file(outfile, args_info->cues_given, "cues", args_info->cues_orig, cmdline_parser_cues_values);
  if (args_info->cue_source_given)
    write_into_file(outfile, "cue-source", args_info->cue_source_orig, cmdline_parser_cue_source_values);
  if (args_info->psb_cheat_given)
    write_into_file(outfile, "psb-cheat", 0, 0 );
  if (args_info->pred_source_given)
    write_into_file(outfile, "pred-source", args_info->pred_source_orig, cmdline_parser_pred_source_values);
  if (args_info->phon_source_given)
    write_into_file(outfile, "phon-source", args_info->phon_source_orig, cmdline_parser_phon_source_values);
  if (args_info->stress_source_given)
    write_into_file(outfile, "stress-source", args_info->stress_source_orig, cmdline_parser_stress_source_values);
  if (args_info->lex_source_given)
    write_into_file(outfile, "lex-source", args_info->lex_source_orig, cmdline_parser_lex_source_values);
  if (args_info->combine_given)
    write_into_file(outfile, "combine", args_info->combine_orig, cmdline_parser_combine_values);
  if (args_info->combine_rate_given)
    write_into_file(outfile, "combine-rate", args_info->combine_rate_orig, 0);
  if (args_info->boundary_method_given)
    write_into_file(outfile, "boundary-method", args_info->boundary_method_orig, cmdline_parser_boundary_method_values);
  if (args_info->peak_given)
    write_into_file(outfile, "peak", args_info->peak_orig, cmdline_parser_peak_values);
  if (args_info->threshold_given)
    write_into_file(outfile, "threshold", args_info->threshold_orig, 0);
  if (args_info->norm_given)
    write_into_file(outfile, "norm", args_info->norm_orig, cmdline_parser_norm_values);
  if (args_info->vote_given)
    write_into_file(outfile, "vote", args_info->vote_orig, cmdline_parser_vote_values);
  if (args_info->prior_data_given)
    write_into_file(outfile, "prior-data", args_info->prior_data_orig, 0);
  

  i = EXIT_SUCCESS;
  return i;
}

int
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  i = cmdline_parser_dump(outfile, args_info);
  fclose (outfile);

  return i;
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  cmdline_parser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = 0;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

static char *
get_multiple_arg_token(const char *arg)
{
  const char *tok;
  char *ret;
  size_t len, num_of_escape, i, j;

  if (!arg)
    return 0;

  tok = strchr (arg, ',');
  num_of_escape = 0;

  /* make sure it is not escaped */
  while (tok)
    {
      if (*(tok-1) == '\\')
        {
          /* find the next one */
          tok = strchr (tok+1, ',');
          ++num_of_escape;
        }
      else
        break;
    }

  if (tok)
    len = (size_t)(tok - arg + 1);
  else
    len = strlen (arg) + 1;

  len -= num_of_escape;

  ret = (char *) malloc (len);

  i = 0;
  j = 0;
  while (arg[i] && (j < len-1))
    {
      if (arg[i] == '\\' && 
	  arg[ i + 1 ] && 
	  arg[ i + 1 ] == ',')
        ++i;

      ret[j++] = arg[i++];
    }

  ret[len-1] = '\0';

  return ret;
}

static const char *
get_multiple_arg_token_next(const char *arg)
{
  const char *tok;

  if (!arg)
    return 0;

  tok = strchr (arg, ',');

  /* make sure it is not escaped */
  while (tok)
    {
      if (*(tok-1) == '\\')
        {
          /* find the next one */
          tok = strchr (tok+1, ',');
        }
      else
        break;
    }

  if (! tok || strlen(tok) == 1)
    return 0;

  return tok+1;
}

static int
check_multiple_option_occurrences(const char *prog_name, unsigned int option_given, unsigned int min, unsigned int max, const char *option_desc);

int
check_multiple_option_occurrences(const char *prog_name, unsigned int option_given, unsigned int min, unsigned int max, const char *option_desc)
{
  int error_occurred = 0;

  if (option_given && (min > 0 || max > 0))
    {
      if (min > 0 && max > 0)
        {
          if (min == max)
            {
              /* specific occurrences */
              if (option_given != (unsigned int) min)
                {
                  fprintf (stderr, "%s: %s option occurrences must be %d\n",
                    prog_name, option_desc, min);
                  error_occurred = 1;
                }
            }
          else if (option_given < (unsigned int) min
                || option_given > (unsigned int) max)
            {
              /* range occurrences */
              fprintf (stderr, "%s: %s option occurrences must be between %d and %d\n",
                prog_name, option_desc, min, max);
              error_occurred = 1;
            }
        }
      else if (min > 0)
        {
          /* at least check */
          if (option_given < min)
            {
              fprintf (stderr, "%s: %s option occurrences must be at least %d\n",
                prog_name, option_desc, min);
              error_occurred = 1;
            }
        }
      else if (max > 0)
        {
          /* at most check */
          if (option_given > max)
            {
              fprintf (stderr, "%s: %s option occurrences must be at most %d\n",
                prog_name, option_desc, max);
              error_occurred = 1;
            }
        }
    }
    
  return error_occurred;
}
int
cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
{
  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,
                   struct cmdline_parser_params *params)
{
  int result;
  result = cmdline_parser_internal (argc, argv, args_info, params, 0);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;
  struct cmdline_parser_params params;
  
  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = cmdline_parser_internal (argc, argv, args_info, &params, 0);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  int result = EXIT_SUCCESS;

  if (cmdline_parser_required2(args_info, prog_name, 0) > 0)
    result = EXIT_FAILURE;

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)
{
  int error_occurred = 0;
  FIX_UNUSED (additional_error);

  /* checks for required options */
  if (check_multiple_option_occurrences(prog_name, args_info->print_ptp_given, args_info->print_ptp_min, args_info->print_ptp_max, "'--print-ptp'"))
     error_occurred = 1;
  
  if (check_multiple_option_occurrences(prog_name, args_info->pred_m_given, args_info->pred_m_min, args_info->pred_m_max, "'--pred-m'"))
     error_occurred = 1;
  
  if (check_multiple_option_occurrences(prog_name, args_info->lex_given, args_info->lex_min, args_info->lex_max, "'--lex'"))
     error_occurred = 1;
  
  if (check_multiple_option_occurrences(prog_name, args_info->cues_given, args_info->cues_min, args_info->cues_max, "'--cues' ('-c')"))
     error_occurred = 1;
  
  
  /* checks for dependences among options */

  return error_occurred;
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see cmdline_parser_params.check_ambiguity
 * @param override @see cmdline_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
               unsigned int *field_given, unsigned int *prev_given, 
               char *value, const char *possible_values[],
               const char *default_value,
               cmdline_parser_arg_type arg_type,
               int check_ambiguity, int override,
               int no_free, int multiple_option,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  char *stop_char = 0;
  const char *val = value;
  int found;
  char **string_field;
  FIX_UNUSED (field);

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
               package_name, long_opt, short_opt,
               (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
               package_name, long_opt,
               (additional_error ? additional_error : ""));
      return 1; /* failure */
    }

  if (possible_values && (found = check_possible_values((value ? value : default_value), possible_values)) < 0)
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: %s argument, \"%s\", for option `--%s' (`-%c')%s\n", 
          package_name, (found == -2) ? "ambiguous" : "invalid", value, long_opt, short_opt,
          (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: %s argument, \"%s\", for option `--%s'%s\n", 
          package_name, (found == -2) ? "ambiguous" : "invalid", value, long_opt,
          (additional_error ? additional_error : ""));
      return 1; /* failure */
    }
    
  if (field_given && *field_given && ! override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch(arg_type) {
  case ARG_FLAG:
    *((int *)field) = !*((int *)field);
    break;
  case ARG_INT:
    if (val) *((int *)field) = strtol (val, &stop_char, 0);
    break;
  case ARG_LONG:
    if (val) *((long *)field) = (long)strtol (val, &stop_char, 0);
    break;
  case ARG_DOUBLE:
    if (val) *((double *)field) = strtod (val, &stop_char);
    break;
  case ARG_ENUM:
    if (val) *((int *)field) = found;
    break;
  case ARG_STRING:
    if (val) {
      string_field = (char **)field;
      if (!no_free && *string_field)
        free (*string_field); /* free previous string */
      *string_field = gengetopt_strdup (val);
    }
    break;
  default:
    break;
  };

  /* check numeric conversion */
  switch(arg_type) {
  case ARG_INT:
  case ARG_LONG:
  case ARG_DOUBLE:
    if (val && !(stop_char && *stop_char == '\0')) {
      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
      return 1; /* failure */
    }
    break;
  default:
    ;
  };

  /* store the original value */
  switch(arg_type) {
  case ARG_NO:
  case ARG_FLAG:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free (*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup (value);
      }
    }
  };

  return 0; /* OK */
}

/**
 * @brief store information about a multiple option in a temporary list
 * @param list where to (temporarily) store multiple options
 */
static
int update_multiple_arg_temp(struct generic_list **list,
               unsigned int *prev_given, const char *val,
               const char *possible_values[], const char *default_value,
               cmdline_parser_arg_type arg_type,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  /* store single arguments */
  char *multi_token;
  const char *multi_next;

  if (arg_type == ARG_NO) {
    (*prev_given)++;
    return 0; /* OK */
  }

  multi_token = get_multiple_arg_token(val);
  multi_next = get_multiple_arg_token_next (val);

  while (1)
    {
      add_node (list);
      if (update_arg((void *)&((*list)->arg), &((*list)->orig), 0,
          prev_given, multi_token, possible_values, default_value, 
          arg_type, 0, 1, 1, 1, long_opt, short_opt, additional_error)) {
        if (multi_token) free(multi_token);
        return 1; /* failure */
      }

      if (multi_next)
        {
          multi_token = get_multiple_arg_token(multi_next);
          multi_next = get_multiple_arg_token_next (multi_next);
        }
      else
        break;
    }

  return 0; /* OK */
}

/**
 * @brief free the passed list (including possible string argument)
 */
static
void free_list(struct generic_list *list, short string_arg)
{
  if (list) {
    struct generic_list *tmp;
    while (list)
      {
        tmp = list;
        if (string_arg && list->arg.string_arg)
          free (list->arg.string_arg);
        if (list->orig)
          free (list->orig);
        list = list->next;
        free (tmp);
      }
  }
}

/**
 * @brief updates a multiple option starting from the passed list
 */
static
void update_multiple_arg(void *field, char ***orig_field,
               unsigned int field_given, unsigned int prev_given, union generic_value *default_value,
               cmdline_parser_arg_type arg_type,
               struct generic_list *list)
{
  int i;
  struct generic_list *tmp;

  if (prev_given && list) {
    *orig_field = (char **) realloc (*orig_field, (field_given + prev_given) * sizeof (char *));

    switch(arg_type) {
    case ARG_INT:
    case ARG_ENUM:
      *((int **)field) = (int *)realloc (*((int **)field), (field_given + prev_given) * sizeof (int)); break;
    case ARG_LONG:
      *((long **)field) = (long *)realloc (*((long **)field), (field_given + prev_given) * sizeof (long)); break;
    case ARG_DOUBLE:
      *((double **)field) = (double *)realloc (*((double **)field), (field_given + prev_given) * sizeof (double)); break;
    case ARG_STRING:
      *((char ***)field) = (char **)realloc (*((char ***)field), (field_given + prev_given) * sizeof (char *)); break;
    default:
      break;
    };
    
    for (i = (prev_given - 1); i >= 0; --i)
      {
        tmp = list;
        
        switch(arg_type) {
        case ARG_INT:
          (*((int **)field))[i + field_given] = tmp->arg.int_arg; break;
        case ARG_LONG:
          (*((long **)field))[i + field_given] = tmp->arg.long_arg; break;
        case ARG_DOUBLE:
          (*((double **)field))[i + field_given] = tmp->arg.double_arg; break;
        case ARG_ENUM:
          (*((int **)field))[i + field_given] = tmp->arg.int_arg; break;
        case ARG_STRING:
          (*((char ***)field))[i + field_given] = tmp->arg.string_arg; break;
        default:
          break;
        }        
        (*orig_field) [i + field_given] = list->orig;
        list = list->next;
        free (tmp);
      }
  } else { /* set the default value */
    if (default_value && ! field_given) {
      switch(arg_type) {
      case ARG_INT:
      case ARG_ENUM:
        if (! *((int **)field)) {
          *((int **)field) = (int *)malloc (sizeof (int));
          (*((int **)field))[0] = default_value->int_arg; 
        }
        break;
      case ARG_LONG:
        if (! *((long **)field)) {
          *((long **)field) = (long *)malloc (sizeof (long));
          (*((long **)field))[0] = default_value->long_arg;
        }
        break;
      case ARG_DOUBLE:
        if (! *((double **)field)) {
          *((double **)field) = (double *)malloc (sizeof (double));
          (*((double **)field))[0] = default_value->double_arg;
        }
        break;
      case ARG_STRING:
        if (! *((char ***)field)) {
          *((char ***)field) = (char **)malloc (sizeof (char *));
          (*((char ***)field))[0] = gengetopt_strdup(default_value->string_arg);
        }
        break;
      default: break;
      }
      if (!(*orig_field)) {
        *orig_field = (char **) malloc (sizeof (char *));
        (*orig_field)[0] = 0;
      }
    }
  }
}

int
cmdline_parser_internal (
  int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */
  union generic_value multiple_default_value;

  struct generic_list * print_ptp_list = NULL;
  struct generic_list * pred_m_list = NULL;
  struct generic_list * lex_list = NULL;
  struct generic_list * cues_list = NULL;
  int error_occurred = 0;
  struct gengetopt_args_info local_args_info;
  
  int override;
  int initialize;
  int check_required;
  int check_ambiguity;
  
  package_name = argv[0];
  
  override = params->override;
  initialize = params->initialize;
  check_required = params->check_required;
  check_ambiguity = params->check_ambiguity;

  if (initialize)
    cmdline_parser_init (args_info);

  cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1)
    {
      int option_index = 0;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "version",	0, NULL, 'V' },
        { "debug",	1, NULL, 'd' },
        { "quiet",	0, NULL, 0 },
        { "color",	0, NULL, 0 },
        { "progress",	2, NULL, 0 },
        { "input",	1, NULL, 'i' },
        { "stress-file",	1, NULL, 0 },
        { "input-format",	1, NULL, 'f' },
        { "output",	1, NULL, 'o' },
        { "inlex",	1, NULL, 'I' },
        { "outlex",	1, NULL, 'O' },
        { "shuffle",	2, NULL, 0 },
        { "print",	0, NULL, 'p' },
        { "print-lb",	0, NULL, 0 },
        { "print-ub",	0, NULL, 0 },
        { "print-header",	0, NULL, 0 },
        { "print-ph",	0, NULL, 0 },
        { "print-phng",	0, NULL, 0 },
        { "print-ptp",	2, NULL, 0 },
        { "print-wfreq",	2, NULL, 0 },
        { "print-wfreq-sum",	0, NULL, 0 },
        { "print-latex",	0, NULL, 0 },
        { "print-prf",	2, NULL, 0 },
        { "score",	1, NULL, 0 },
        { "score-edges",	0, NULL, 0 },
        { "alpha",	1, NULL, 0 },
        { "pred-m",	1, NULL, 0 },
        { "pred-norm",	0, NULL, 0 },
        { "pred-xlen",	1, NULL, 0 },
        { "pred-ylen",	1, NULL, 0 },
        { "pred-xmax",	1, NULL, 0 },
        { "pred-ymax",	1, NULL, 0 },
        { "pred-xmin",	1, NULL, 0 },
        { "pred-ymin",	1, NULL, 0 },
        { "pred-printw",	0, NULL, 0 },
        { "pred-printoptions",	0, NULL, 0 },
        { "pred-swaplr",	0, NULL, 0 },
        { "random-seed",	1, NULL, 0 },
        { "random-rate",	1, NULL, 0 },
        { "lexicon-partial",	2, NULL, 0 },
        { "lex-nglen",	1, NULL, 0 },
        { "lex-useprior",	0, NULL, 0 },
        { "lex-minfreq",	1, NULL, 0 },
        { "lex-minent",	1, NULL, 0 },
        { "lex-mult",	1, NULL, 0 },
        { "lex-wcombine",	1, NULL, 0 },
        { "lex-norm",	1, NULL, 0 },
        { "lex",	1, NULL, 0 },
        { "lex-dir",	1, NULL, 0 },
        { "stress",	1, NULL, 0 },
        { "ub-nglen",	1, NULL, 0 },
        { "ub-ngmin",	1, NULL, 0 },
        { "ub-ngmax",	1, NULL, 0 },
        { "ub-lmin",	1, NULL, 0 },
        { "ub-lmax",	1, NULL, 0 },
        { "ub-rmin",	1, NULL, 0 },
        { "ub-rmax",	1, NULL, 0 },
        { "ub-type",	1, NULL, 0 },
        { "sub-ngmin",	1, NULL, 0 },
        { "sub-ngmax",	1, NULL, 0 },
        { "method",	1, NULL, 'm' },
        { "cues",	1, NULL, 'c' },
        { "cue-source",	1, NULL, 0 },
        { "psb-cheat",	0, NULL, 0 },
        { "pred-source",	1, NULL, 0 },
        { "phon-source",	1, NULL, 0 },
        { "stress-source",	1, NULL, 0 },
        { "lex-source",	1, NULL, 0 },
        { "combine",	1, NULL, 0 },
        { "combine-rate",	1, NULL, 0 },
        { "boundary-method",	1, NULL, 0 },
        { "peak",	1, NULL, 0 },
        { "threshold",	1, NULL, 0 },
        { "norm",	1, NULL, 0 },
        { "vote",	1, NULL, 0 },
        { "prior-data",	2, NULL, 0 },
        { 0,  0, 0, 0 }
      };

      c = getopt_long (argc, argv, "hVd:i:f:o:I:O:pm:c:", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          cmdline_parser_print_help ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          cmdline_parser_print_version ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'd':	/* debug level.  */
        
        
          if (update_arg( (void *)&(args_info->debug_arg), 
               &(args_info->debug_orig), &(args_info->debug_given),
              &(local_args_info.debug_given), optarg, 0, "0", ARG_INT,
              check_ambiguity, override, 0, 0,
              "debug", 'd',
              additional_error))
            goto failure;
        
          break;
        case 'i':	/* input file name.  */
        
        
          if (update_arg( (void *)&(args_info->input_arg), 
               &(args_info->input_orig), &(args_info->input_given),
              &(local_args_info.input_given), optarg, 0, "br-phono.txt", ARG_STRING,
              check_ambiguity, override, 0, 0,
              "input", 'i',
              additional_error))
            goto failure;
        
          break;
        case 'f':	/* input file format:
         seg: one segmented utterance/word per line
         unseg: one unsegmented utterance/word per line
         mc: MorphoChallenge format, <freq,unseg> pairs.  */
        
        
          if (update_arg( (void *)&(args_info->input_format_arg), 
               &(args_info->input_format_orig), &(args_info->input_format_given),
              &(local_args_info.input_format_given), optarg, cmdline_parser_input_format_values, "seg", ARG_ENUM,
              check_ambiguity, override, 0, 0,
              "input-format", 'f',
              additional_error))
            goto failure;
        
          break;
        case 'o':	/* output file name.  */
        
        
          if (update_arg( (void *)&(args_info->output_arg), 
               &(args_info->output_orig), &(args_info->output_given),
              &(local_args_info.output_given), optarg, 0, "-", ARG_STRING,
              check_ambiguity, override, 0, 0,
              "output", 'o',
              additional_error))
            goto failure;
        
          break;
        case 'I':	/* input lexicon file.  */
        
        
          if (update_arg( (void *)&(args_info->inlex_arg), 
               &(args_info->inlex_orig), &(args_info->inlex_given),
              &(local_args_info.inlex_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "inlex", 'I',
              additional_error))
            goto failure;
        
          break;
        case 'O':	/* output lexicon file.  */
        
        
          if (update_arg( (void *)&(args_info->outlex_arg), 
               &(args_info->outlex_orig), &(args_info->outlex_given),
              &(local_args_info.outlex_given), optarg, 0, "-", ARG_STRING,
              check_ambiguity, override, 0, 0,
              "outlex", 'O',
              additional_error))
            goto failure;
        
          break;
        case 'p':	/* print predictability measures given in --pred and exit.  */
        
        
          if (update_arg((void *)&(args_info->print_flag), 0, &(args_info->print_given),
              &(local_args_info.print_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "print", 'p',
              additional_error))
            goto failure;
        
          break;
        case 'm':	/* segmentation method(s), some can be combined.  */
        
        
          if (update_arg( (void *)&(args_info->method_arg), 
               &(args_info->method_orig), &(args_info->method_given),
              &(local_args_info.method_given), optarg, cmdline_parser_method_values, "combine", ARG_ENUM,
              check_ambiguity, override, 0, 0,
              "method", 'm',
              additional_error))
            goto failure;
        
          break;
        case 'c':	/* list of cues to combine.  */
        
          if (update_multiple_arg_temp(&cues_list, 
              &(local_args_info.cues_given), optarg, cmdline_parser_cues_values, "pred", ARG_ENUM,
              "cues", 'c',
              additional_error))
            goto failure;
        
          break;

        case 0:	/* Long option with no short option */
          /* be quiet.  */
          if (strcmp (long_options[option_index].name, "quiet") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->quiet_flag), 0, &(args_info->quiet_given),
                &(local_args_info.quiet_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "quiet", '-',
                additional_error))
              goto failure;
          
          }
          /* color output.  */
          else if (strcmp (long_options[option_index].name, "color") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->color_flag), 0, &(args_info->color_given),
                &(local_args_info.color_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "color", '-',
                additional_error))
              goto failure;
          
          }
          /* print progress.  */
          else if (strcmp (long_options[option_index].name, "progress") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->progress_arg), 
                 &(args_info->progress_orig), &(args_info->progress_given),
                &(local_args_info.progress_given), optarg, 0, "100", ARG_INT,
                check_ambiguity, override, 0, 0,
                "progress", '-',
                additional_error))
              goto failure;
          
          }
          /*  filename to read stress patterns from.  */
          else if (strcmp (long_options[option_index].name, "stress-file") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->stress_file_arg), 
                 &(args_info->stress_file_orig), &(args_info->stress_file_given),
                &(local_args_info.stress_file_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "stress-file", '-',
                additional_error))
              goto failure;
          
          }
          /* randomize the input utternaces. if SEED is not given, current time is used as seed.  */
          else if (strcmp (long_options[option_index].name, "shuffle") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->shuffle_arg), 
                 &(args_info->shuffle_orig), &(args_info->shuffle_given),
                &(local_args_info.shuffle_given), optarg, 0, "-1", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "shuffle", '-',
                additional_error))
              goto failure;
          
          }
          /* print word boundary information for each measure.  */
          else if (strcmp (long_options[option_index].name, "print-lb") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->print_lb_flag), 0, &(args_info->print_lb_given),
                &(local_args_info.print_lb_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "print-lb", '-',
                additional_error))
              goto failure;
          
          }
          /* print utterance boundary information for each measure.  */
          else if (strcmp (long_options[option_index].name, "print-ub") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->print_ub_flag), 0, &(args_info->print_ub_given),
                &(local_args_info.print_ub_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "print-ub", '-',
                additional_error))
              goto failure;
          
          }
          /* print a header describing each field.  */
          else if (strcmp (long_options[option_index].name, "print-header") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->print_header_flag), 0, &(args_info->print_header_given),
                &(local_args_info.print_header_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "print-header", '-',
                additional_error))
              goto failure;
          
          }
          /* print the phoneme before the predictability measure.  */
          else if (strcmp (long_options[option_index].name, "print-ph") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->print_ph_flag), 0, &(args_info->print_ph_given),
                &(local_args_info.print_ph_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "print-ph", '-',
                additional_error))
              goto failure;
          
          }
          /* print phoneme ngrams before the predictability measure.  */
          else if (strcmp (long_options[option_index].name, "print-phng") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->print_phng_flag), 0, &(args_info->print_phng_given),
                &(local_args_info.print_phng_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "print-phng", '-',
                additional_error))
              goto failure;
          
          }
          /* Print Hockema's ptp values, and some more.  */
          else if (strcmp (long_options[option_index].name, "print-ptp") == 0)
          {
          
            if (update_multiple_arg_temp(&print_ptp_list, 
                &(local_args_info.print_ptp_given), optarg, cmdline_parser_print_ptp_values, "none", ARG_ENUM,
                "print-ptp", '-',
                additional_error))
              goto failure;
          
          }
          /* Print frequency of all candidate words upto length N.  */
          else if (strcmp (long_options[option_index].name, "print-wfreq") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->print_wfreq_arg), 
                 &(args_info->print_wfreq_orig), &(args_info->print_wfreq_given),
                &(local_args_info.print_wfreq_given), optarg, 0, "11", ARG_INT,
                check_ambiguity, override, 0, 0,
                "print-wfreq", '-',
                additional_error))
              goto failure;
          
          }
          /* Print summary during --print-wfreq.  */
          else if (strcmp (long_options[option_index].name, "print-wfreq-sum") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->print_wfreq_sum_flag), 0, &(args_info->print_wfreq_sum_given),
                &(local_args_info.print_wfreq_sum_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "print-wfreq-sum", '-',
                additional_error))
              goto failure;
          
          }
          /* print tabular material with latex separators.  */
          else if (strcmp (long_options[option_index].name, "print-latex") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->print_latex_flag), 0, &(args_info->print_latex_given),
                &(local_args_info.print_latex_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "print-latex", '-',
                additional_error))
              goto failure;
          
          }
          /* print precision/recall/f-score. If the optional
          argument, N,  is given and positive, print the scores after every N input
          utterance. If N is negative, the print the scores for last N
          utterances..  */
          else if (strcmp (long_options[option_index].name, "print-prf") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->print_prf_arg), 
                 &(args_info->print_prf_orig), &(args_info->print_prf_given),
                &(local_args_info.print_prf_given), optarg, 0, "0", ARG_INT,
                check_ambiguity, override, 0, 0,
                "print-prf", '-',
                additional_error))
              goto failure;
          
          }
          /* the segmentation to pick in case of multiple outputs.  */
          else if (strcmp (long_options[option_index].name, "score") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->score_arg), 
                 &(args_info->score_orig), &(args_info->score_given),
                &(local_args_info.score_given), optarg, cmdline_parser_score_values, "first", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "score", '-',
                additional_error))
              goto failure;
          
          }
          /* include utterance edges in BP/BR calculation.  */
          else if (strcmp (long_options[option_index].name, "score-edges") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->score_edges_flag), 0, &(args_info->score_edges_given),
                &(local_args_info.score_edges_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "score-edges", '-',
                additional_error))
              goto failure;
          
          }
          /* parameter for lm1 segmentation.  */
          else if (strcmp (long_options[option_index].name, "alpha") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->alpha_arg), 
                 &(args_info->alpha_orig), &(args_info->alpha_given),
                &(local_args_info.alpha_given), optarg, 0, "0.5", ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "alpha", '-',
                additional_error))
              goto failure;
          
          }
          /* measure(s) to use for predictability based segmentation.  */
          else if (strcmp (long_options[option_index].name, "pred-m") == 0)
          {
          
            if (update_multiple_arg_temp(&pred_m_list, 
                &(local_args_info.pred_m_given), optarg, cmdline_parser_pred_m_values, "tp", ARG_ENUM,
                "pred-m", '-',
                additional_error))
              goto failure;
          
          }
          /* normalize the predictability scores.  */
          else if (strcmp (long_options[option_index].name, "pred-norm") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->pred_norm_flag), 0, &(args_info->pred_norm_given),
                &(local_args_info.pred_norm_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "pred-norm", '-',
                additional_error))
              goto failure;
          
          }
          /* first ngram size for predictability based measures.  */
          else if (strcmp (long_options[option_index].name, "pred-xlen") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->pred_xlen_arg), 
                 &(args_info->pred_xlen_orig), &(args_info->pred_xlen_given),
                &(local_args_info.pred_xlen_given), optarg, 0, "1", ARG_INT,
                check_ambiguity, override, 0, 0,
                "pred-xlen", '-',
                additional_error))
              goto failure;
          
          }
          /* second ngram size for predictability based measures.  */
          else if (strcmp (long_options[option_index].name, "pred-ylen") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->pred_ylen_arg), 
                 &(args_info->pred_ylen_orig), &(args_info->pred_ylen_given),
                &(local_args_info.pred_ylen_given), optarg, 0, "1", ARG_INT,
                check_ambiguity, override, 0, 0,
                "pred-ylen", '-',
                additional_error))
              goto failure;
          
          }
          /* max first ngram size for predictability based measures.  */
          else if (strcmp (long_options[option_index].name, "pred-xmax") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->pred_xmax_arg), 
                 &(args_info->pred_xmax_orig), &(args_info->pred_xmax_given),
                &(local_args_info.pred_xmax_given), optarg, 0, "3", ARG_INT,
                check_ambiguity, override, 0, 0,
                "pred-xmax", '-',
                additional_error))
              goto failure;
          
          }
          /* max second ngram size for predictability based measures.  */
          else if (strcmp (long_options[option_index].name, "pred-ymax") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->pred_ymax_arg), 
                 &(args_info->pred_ymax_orig), &(args_info->pred_ymax_given),
                &(local_args_info.pred_ymax_given), optarg, 0, "1", ARG_INT,
                check_ambiguity, override, 0, 0,
                "pred-ymax", '-',
                additional_error))
              goto failure;
          
          }
          /* min first ngram size for predictability based measures.  */
          else if (strcmp (long_options[option_index].name, "pred-xmin") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->pred_xmin_arg), 
                 &(args_info->pred_xmin_orig), &(args_info->pred_xmin_given),
                &(local_args_info.pred_xmin_given), optarg, 0, "1", ARG_INT,
                check_ambiguity, override, 0, 0,
                "pred-xmin", '-',
                additional_error))
              goto failure;
          
          }
          /* min second ngram size for predictability based measures.  */
          else if (strcmp (long_options[option_index].name, "pred-ymin") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->pred_ymin_arg), 
                 &(args_info->pred_ymin_orig), &(args_info->pred_ymin_given),
                &(local_args_info.pred_ymin_given), optarg, 0, "1", ARG_INT,
                check_ambiguity, override, 0, 0,
                "pred-ymin", '-',
                additional_error))
              goto failure;
          
          }
          /* print the final weights at the end of the segmentation.  */
          else if (strcmp (long_options[option_index].name, "pred-printw") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->pred_printw_flag), 0, &(args_info->pred_printw_given),
                &(local_args_info.pred_printw_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "pred-printw", '-',
                additional_error))
              goto failure;
          
          }
          /* print the options before the segmentation.  */
          else if (strcmp (long_options[option_index].name, "pred-printoptions") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->pred_printoptions_flag), 0, &(args_info->pred_printoptions_given),
                &(local_args_info.pred_printoptions_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "pred-printoptions", '-',
                additional_error))
              goto failure;
          
          }
          /* swap the l & r values for reverse measures.  */
          else if (strcmp (long_options[option_index].name, "pred-swaplr") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->pred_swaplr_flag), 0, &(args_info->pred_swaplr_given),
                &(local_args_info.pred_swaplr_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "pred-swaplr", '-',
                additional_error))
              goto failure;
          
          }
          /* seed for pseudo-random number generator.  */
          else if (strcmp (long_options[option_index].name, "random-seed") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->random_seed_arg), 
                 &(args_info->random_seed_orig), &(args_info->random_seed_given),
                &(local_args_info.random_seed_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "random-seed", '-',
                additional_error))
              goto failure;
          
          }
          /* rate of boundaries, should be a number between 0 (no boundaries) an 1 (all boundaries).  */
          else if (strcmp (long_options[option_index].name, "random-rate") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->random_rate_arg), 
                 &(args_info->random_rate_orig), &(args_info->random_rate_given),
                &(local_args_info.random_rate_given), optarg, 0, "0.5", ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "random-rate", '-',
                additional_error))
              goto failure;
          
          }
          /* do partial segmentation.  */
          else if (strcmp (long_options[option_index].name, "lexicon-partial") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->lexicon_partial_arg), 
                 &(args_info->lexicon_partial_orig), &(args_info->lexicon_partial_given),
                &(local_args_info.lexicon_partial_given), optarg, cmdline_parser_lexicon_partial_values, "none", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "lexicon-partial", '-',
                additional_error))
              goto failure;
          
          }
          /* ngram size for keeping statistics about the phonemes in the lexicon.  */
          else if (strcmp (long_options[option_index].name, "lex-nglen") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->lex_nglen_arg), 
                 &(args_info->lex_nglen_orig), &(args_info->lex_nglen_given),
                &(local_args_info.lex_nglen_given), optarg, 0, "5", ARG_INT,
                check_ambiguity, override, 0, 0,
                "lex-nglen", '-',
                additional_error))
              goto failure;
          
          }
          /* use utterances in --prior-data as initial lexicon statistics.  */
          else if (strcmp (long_options[option_index].name, "lex-useprior") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->lex_useprior_flag), 0, &(args_info->lex_useprior_given),
                &(local_args_info.lex_useprior_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "lex-useprior", '-',
                additional_error))
              goto failure;
          
          }
          /* frequencey of an ngram to qualify as a word.  */
          else if (strcmp (long_options[option_index].name, "lex-minfreq") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->lex_minfreq_arg), 
                 &(args_info->lex_minfreq_orig), &(args_info->lex_minfreq_given),
                &(local_args_info.lex_minfreq_given), optarg, 0, "0.0", ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "lex-minfreq", '-',
                additional_error))
              goto failure;
          
          }
          /* left and right entropy of an ngram to qualify as a word.  */
          else if (strcmp (long_options[option_index].name, "lex-minent") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->lex_minent_arg), 
                 &(args_info->lex_minent_orig), &(args_info->lex_minent_given),
                &(local_args_info.lex_minent_given), optarg, 0, "-1.0", ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "lex-minent", '-',
                additional_error))
              goto failure;
          
          }
          /* multiply lexicon votes N times.  */
          else if (strcmp (long_options[option_index].name, "lex-mult") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->lex_mult_arg), 
                 &(args_info->lex_mult_orig), &(args_info->lex_mult_given),
                &(local_args_info.lex_mult_given), optarg, 0, "1", ARG_INT,
                check_ambiguity, override, 0, 0,
                "lex-mult", '-',
                additional_error))
              goto failure;
          
          }
          /* how to combine LF/LC for multiple words.  */
          else if (strcmp (long_options[option_index].name, "lex-wcombine") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->lex_wcombine_arg), 
                 &(args_info->lex_wcombine_orig), &(args_info->lex_wcombine_given),
                &(local_args_info.lex_wcombine_given), optarg, cmdline_parser_lex_wcombine_values, "sum", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "lex-wcombine", '-',
                additional_error))
              goto failure;
          
          }
          /* normalization method for LF/LC.  */
          else if (strcmp (long_options[option_index].name, "lex-norm") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->lex_norm_arg), 
                 &(args_info->lex_norm_orig), &(args_info->lex_norm_given),
                &(local_args_info.lex_norm_given), optarg, cmdline_parser_lex_norm_values, "none", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "lex-norm", '-',
                additional_error))
              goto failure;
          
          }
          /* measure(s) to use for lexicon based segmentation.  */
          else if (strcmp (long_options[option_index].name, "lex") == 0)
          {
          
            if (update_multiple_arg_temp(&lex_list, 
                &(local_args_info.lex_given), optarg, cmdline_parser_lex_values, "lf", ARG_ENUM,
                "lex", '-',
                additional_error))
              goto failure;
          
          }
          /* direction of lexal measures.  */
          else if (strcmp (long_options[option_index].name, "lex-dir") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->lex_dir_arg), 
                 &(args_info->lex_dir_orig), &(args_info->lex_dir_given),
                &(local_args_info.lex_dir_given), optarg, cmdline_parser_lex_dir_values, "both", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "lex-dir", '-',
                additional_error))
              goto failure;
          
          }
          /* method to calculate stress information.  */
          else if (strcmp (long_options[option_index].name, "stress") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->stress_arg), 
                 &(args_info->stress_orig), &(args_info->stress_given),
                &(local_args_info.stress_given), optarg, cmdline_parser_stress_values, "ub", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "stress", '-',
                additional_error))
              goto failure;
          
          }
          /* phoneme ngram length.  */
          else if (strcmp (long_options[option_index].name, "ub-nglen") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ub_nglen_arg), 
                 &(args_info->ub_nglen_orig), &(args_info->ub_nglen_given),
                &(local_args_info.ub_nglen_given), optarg, 0, "2", ARG_INT,
                check_ambiguity, override, 0, 0,
                "ub-nglen", '-',
                additional_error))
              goto failure;
          
          }
          /* minimum phoneme ngram length.  */
          else if (strcmp (long_options[option_index].name, "ub-ngmin") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ub_ngmin_arg), 
                 &(args_info->ub_ngmin_orig), &(args_info->ub_ngmin_given),
                &(local_args_info.ub_ngmin_given), optarg, 0, "1", ARG_INT,
                check_ambiguity, override, 0, 0,
                "ub-ngmin", '-',
                additional_error))
              goto failure;
          
          }
          /* maximum phoneme ngram length.  */
          else if (strcmp (long_options[option_index].name, "ub-ngmax") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ub_ngmax_arg), 
                 &(args_info->ub_ngmax_orig), &(args_info->ub_ngmax_given),
                &(local_args_info.ub_ngmax_given), optarg, 0, "3", ARG_INT,
                check_ambiguity, override, 0, 0,
                "ub-ngmax", '-',
                additional_error))
              goto failure;
          
          }
          /* maximum left phoneme ngram length.  */
          else if (strcmp (long_options[option_index].name, "ub-lmin") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ub_lmin_arg), 
                 &(args_info->ub_lmin_orig), &(args_info->ub_lmin_given),
                &(local_args_info.ub_lmin_given), optarg, 0, "1", ARG_INT,
                check_ambiguity, override, 0, 0,
                "ub-lmin", '-',
                additional_error))
              goto failure;
          
          }
          /* minimum left phoneme ngram length.  */
          else if (strcmp (long_options[option_index].name, "ub-lmax") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ub_lmax_arg), 
                 &(args_info->ub_lmax_orig), &(args_info->ub_lmax_given),
                &(local_args_info.ub_lmax_given), optarg, 0, "3", ARG_INT,
                check_ambiguity, override, 0, 0,
                "ub-lmax", '-',
                additional_error))
              goto failure;
          
          }
          /* maximum right phoneme ngram length.  */
          else if (strcmp (long_options[option_index].name, "ub-rmin") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ub_rmin_arg), 
                 &(args_info->ub_rmin_orig), &(args_info->ub_rmin_given),
                &(local_args_info.ub_rmin_given), optarg, 0, "1", ARG_INT,
                check_ambiguity, override, 0, 0,
                "ub-rmin", '-',
                additional_error))
              goto failure;
          
          }
          /* minimum right phoneme ngram length.  */
          else if (strcmp (long_options[option_index].name, "ub-rmax") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ub_rmax_arg), 
                 &(args_info->ub_rmax_orig), &(args_info->ub_rmax_given),
                &(local_args_info.ub_rmax_given), optarg, 0, "3", ARG_INT,
                check_ambiguity, override, 0, 0,
                "ub-rmax", '-',
                additional_error))
              goto failure;
          
          }
          /* part of the utterance boundaries to use.  */
          else if (strcmp (long_options[option_index].name, "ub-type") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ub_type_arg), 
                 &(args_info->ub_type_orig), &(args_info->ub_type_given),
                &(local_args_info.ub_type_given), optarg, cmdline_parser_ub_type_values, "both", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "ub-type", '-',
                additional_error))
              goto failure;
          
          }
          /* minimum ngram length for stress (otherwise inherited from ub-ngmin).  */
          else if (strcmp (long_options[option_index].name, "sub-ngmin") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->sub_ngmin_arg), 
                 &(args_info->sub_ngmin_orig), &(args_info->sub_ngmin_given),
                &(local_args_info.sub_ngmin_given), optarg, 0, "2", ARG_INT,
                check_ambiguity, override, 0, 0,
                "sub-ngmin", '-',
                additional_error))
              goto failure;
          
          }
          /* maximum ngram length for stress (otherwise inherited from ub-ngmax).  */
          else if (strcmp (long_options[option_index].name, "sub-ngmax") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->sub_ngmax_arg), 
                 &(args_info->sub_ngmax_orig), &(args_info->sub_ngmax_given),
                &(local_args_info.sub_ngmax_given), optarg, 0, "2", ARG_INT,
                check_ambiguity, override, 0, 0,
                "sub-ngmax", '-',
                additional_error))
              goto failure;
          
          }
          /* default source for all cues.  */
          else if (strcmp (long_options[option_index].name, "cue-source") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->cue_source_arg), 
                 &(args_info->cue_source_orig), &(args_info->cue_source_given),
                &(local_args_info.cue_source_given), optarg, cmdline_parser_cue_source_values, "utterances", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "cue-source", '-',
                additional_error))
              goto failure;
          
          }
          /* update statistics for source=segm first from the utterances, and later when boundaries are decided.  */
          else if (strcmp (long_options[option_index].name, "psb-cheat") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->psb_cheat_flag), 0, &(args_info->psb_cheat_given),
                &(local_args_info.psb_cheat_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "psb-cheat", '-',
                additional_error))
              goto failure;
          
          }
          /* source for all predictability statistics.  */
          else if (strcmp (long_options[option_index].name, "pred-source") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->pred_source_arg), 
                 &(args_info->pred_source_orig), &(args_info->pred_source_given),
                &(local_args_info.pred_source_given), optarg, cmdline_parser_pred_source_values, 0, ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "pred-source", '-',
                additional_error))
              goto failure;
          
          }
          /* source for all phonotactics statistics.  */
          else if (strcmp (long_options[option_index].name, "phon-source") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->phon_source_arg), 
                 &(args_info->phon_source_orig), &(args_info->phon_source_given),
                &(local_args_info.phon_source_given), optarg, cmdline_parser_phon_source_values, 0, ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "phon-source", '-',
                additional_error))
              goto failure;
          
          }
          /* source for all stress statistics.  */
          else if (strcmp (long_options[option_index].name, "stress-source") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->stress_source_arg), 
                 &(args_info->stress_source_orig), &(args_info->stress_source_given),
                &(local_args_info.stress_source_given), optarg, cmdline_parser_stress_source_values, 0, ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "stress-source", '-',
                additional_error))
              goto failure;
          
          }
          /* source for all lexicon statistics.  */
          else if (strcmp (long_options[option_index].name, "lex-source") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->lex_source_arg), 
                 &(args_info->lex_source_orig), &(args_info->lex_source_given),
                &(local_args_info.lex_source_given), optarg, cmdline_parser_lex_source_values, 0, ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "lex-source", '-',
                additional_error))
              goto failure;
          
          }
          /* combination method for multiple cues.  */
          else if (strcmp (long_options[option_index].name, "combine") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->combine_arg), 
                 &(args_info->combine_orig), &(args_info->combine_given),
                &(local_args_info.combine_given), optarg, cmdline_parser_combine_values, "wmv", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "combine", '-',
                additional_error))
              goto failure;
          
          }
          /* rate of votes for deciding for a boundary.  */
          else if (strcmp (long_options[option_index].name, "combine-rate") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->combine_rate_arg), 
                 &(args_info->combine_rate_orig), &(args_info->combine_rate_given),
                &(local_args_info.combine_rate_given), optarg, 0, "0.5", ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "combine-rate", '-',
                additional_error))
              goto failure;
          
          }
          /* method to decide for a boundary.  */
          else if (strcmp (long_options[option_index].name, "boundary-method") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->boundary_method_arg), 
                 &(args_info->boundary_method_orig), &(args_info->boundary_method_given),
                &(local_args_info.boundary_method_given), optarg, cmdline_parser_boundary_method_values, "peak", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "boundary-method", '-',
                additional_error))
              goto failure;
          
          }
          /* how to count peaks for peak based decision.  */
          else if (strcmp (long_options[option_index].name, "peak") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->peak_arg), 
                 &(args_info->peak_orig), &(args_info->peak_given),
                &(local_args_info.peak_given), optarg, cmdline_parser_peak_values, "dual", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "peak", '-',
                additional_error))
              goto failure;
          
          }
          /* threshold to use for deciding boundaries.  */
          else if (strcmp (long_options[option_index].name, "threshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->threshold_arg), 
                 &(args_info->threshold_orig), &(args_info->threshold_given),
                &(local_args_info.threshold_given), optarg, 0, "0.0", ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "threshold", '-',
                additional_error))
              goto failure;
          
          }
          /* normalize the measures with given method before using.  */
          else if (strcmp (long_options[option_index].name, "norm") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->norm_arg), 
                 &(args_info->norm_orig), &(args_info->norm_given),
                &(local_args_info.norm_given), optarg, cmdline_parser_norm_values, "none", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "norm", '-',
                additional_error))
              goto failure;
          
          }
          /* what to return as vote.  */
          else if (strcmp (long_options[option_index].name, "vote") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->vote_arg), 
                 &(args_info->vote_orig), &(args_info->vote_given),
                &(local_args_info.vote_given), optarg, cmdline_parser_vote_values, "binary", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "vote", '-',
                additional_error))
              goto failure;
          
          }
          /* filename to build prior statistics from, if filename is not specified, the statistics are calculated on the first pass on the input file..  */
          else if (strcmp (long_options[option_index].name, "prior-data") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->prior_data_arg), 
                 &(args_info->prior_data_orig), &(args_info->prior_data_given),
                &(local_args_info.prior_data_given), optarg, 0, "input", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "prior-data", '-',
                additional_error))
              goto failure;
          
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */


  multiple_default_value.int_arg = print_ptp_arg_none;
  update_multiple_arg((void *)&(args_info->print_ptp_arg),
    &(args_info->print_ptp_orig), args_info->print_ptp_given,
    local_args_info.print_ptp_given, &multiple_default_value,
    ARG_ENUM, print_ptp_list);
  multiple_default_value.int_arg = pred_m_arg_tp;
  update_multiple_arg((void *)&(args_info->pred_m_arg),
    &(args_info->pred_m_orig), args_info->pred_m_given,
    local_args_info.pred_m_given, &multiple_default_value,
    ARG_ENUM, pred_m_list);
  multiple_default_value.int_arg = lex_arg_lf;
  update_multiple_arg((void *)&(args_info->lex_arg),
    &(args_info->lex_orig), args_info->lex_given,
    local_args_info.lex_given, &multiple_default_value,
    ARG_ENUM, lex_list);
  multiple_default_value.int_arg = cues_arg_pred;
  update_multiple_arg((void *)&(args_info->cues_arg),
    &(args_info->cues_orig), args_info->cues_given,
    local_args_info.cues_given, &multiple_default_value,
    ARG_ENUM, cues_list);

  args_info->print_ptp_given += local_args_info.print_ptp_given;
  local_args_info.print_ptp_given = 0;
  args_info->pred_m_given += local_args_info.pred_m_given;
  local_args_info.pred_m_given = 0;
  args_info->lex_given += local_args_info.lex_given;
  local_args_info.lex_given = 0;
  args_info->cues_given += local_args_info.cues_given;
  local_args_info.cues_given = 0;
  
  if (check_required)
    {
      error_occurred += cmdline_parser_required2 (args_info, argv[0], additional_error);
    }

  cmdline_parser_release (&local_args_info);

  if ( error_occurred )
    return (EXIT_FAILURE);

  return 0;

failure:
  free_list (print_ptp_list, 0 );
  free_list (pred_m_list, 0 );
  free_list (lex_list, 0 );
  free_list (cues_list, 0 );
  
  cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}
